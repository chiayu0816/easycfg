package easycfg

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"github.com/go-yaml/yaml"
)

// YamlToStruct converts YAML file to Go struct and generates Go file
func YamlToStruct(yamlFilePath, outputDir, packageName string) error {
	// Read YAML file
	yamlData, err := os.ReadFile(yamlFilePath)
	if err != nil {
		return fmt.Errorf("failed to read YAML file: %v", err)
	}

	// Parse YAML data
	var yamlMap map[interface{}]interface{}
	if err := yaml.Unmarshal(yamlData, &yamlMap); err != nil {
		return fmt.Errorf("failed to parse YAML data: %v", err)
	}

	// Get file name (without extension) as struct name
	baseName := filepath.Base(yamlFilePath)
	structName := strings.TrimSuffix(baseName, filepath.Ext(baseName))
	structName = toCamelCase(structName)

	// Generate Go struct code
	var nestedStructs []string
	mainStruct := generateMainStruct(yamlMap, structName, &nestedStructs)

	// Combine all struct codes
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("// This file is automatically generated by easycfg, do not modify manually\n"))
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString(mainStruct)

	for _, nestedStruct := range nestedStructs {
		sb.WriteString("\n" + nestedStruct)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}

	// Write Go file
	outputFilePath := filepath.Join(outputDir, strings.ToLower(structName)+".go")
	if err := os.WriteFile(outputFilePath, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write Go file: %v", err)
	}

	fmt.Printf("Successfully generated Go struct file: %s\n", outputFilePath)
	return nil
}

// generateMainStruct generates the main struct
func generateMainStruct(yamlMap map[interface{}]interface{}, structName string, nestedStructs *[]string) string {
	var sb strings.Builder

	// Generate main struct
	sb.WriteString(fmt.Sprintf("// %s configuration struct\n", structName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

	// Iterate through YAML map and generate struct fields
	for key, value := range yamlMap {
		fieldName := toCamelCase(key.(string))
		fieldType, nestedStruct := getFieldTypeAndNestedStruct(value, fieldName, nestedStructs)

		// Add field
		sb.WriteString(fmt.Sprintf("\t%s %s `yaml:\"%s\" mapstructure:\"%s\"`\n",
			fieldName, fieldType, key, key))

		// If there is a nested struct, add it to the list
		if nestedStruct != "" {
			*nestedStructs = append(*nestedStructs, nestedStruct)
		}
	}

	sb.WriteString("}\n")
	return sb.String()
}

// getFieldTypeAndNestedStruct gets field type and nested struct
func getFieldTypeAndNestedStruct(value interface{}, fieldName string, nestedStructs *[]string) (string, string) {
	switch v := value.(type) {
	case map[interface{}]interface{}:
		// Nested struct
		structName := fieldName
		var sb strings.Builder
		sb.WriteString(fmt.Sprintf("// %s nested struct\n", structName))
		sb.WriteString(fmt.Sprintf("type %s struct {\n", structName))

		for key, val := range v {
			subFieldName := toCamelCase(key.(string))
			subFieldType, subNestedStruct := getFieldTypeAndNestedStruct(val, structName+subFieldName, nestedStructs)

			sb.WriteString(fmt.Sprintf("\t%s %s `yaml:\"%s\" mapstructure:\"%s\"`\n",
				subFieldName, subFieldType, key, key))

			if subNestedStruct != "" {
				*nestedStructs = append(*nestedStructs, subNestedStruct)
			}
		}

		sb.WriteString("}\n")
		return structName, sb.String()
	case []interface{}:
		// Array/slice
		if len(v) > 0 {
			elemType, _ := getFieldTypeAndNestedStruct(v[0], fieldName+"Elem", nestedStructs)
			return "[]" + elemType, ""
		}
		return "[]interface{}", ""
	case string:
		return "string", ""
	case int:
		return "int", ""
	case float64:
		return "float64", ""
	case bool:
		return "bool", ""
	default:
		return "interface{}", ""
	}
}

// toCamelCase converts snake_case to CamelCase
func toCamelCase(s string) string {
	// Handle special characters
	reg := regexp.MustCompile("[^a-zA-Z0-9]+")
	s = reg.ReplaceAllString(s, "_")

	// Split string
	parts := strings.Split(s, "_")

	// Convert to CamelCase
	for i := range parts {
		if len(parts[i]) > 0 {
			r := []rune(parts[i])
			r[0] = unicode.ToUpper(r[0])
			parts[i] = string(r)
		}
	}

	return strings.Join(parts, "")
}
